#' checkPythonDeps.R
#'
#' Verify the availability of REMIND's Python dependencies on the host system.
#'
#' @author Tonn RÃ¼ter
#' @export
#' @importFrom reticulate import
#' @importFrom stringr regex str_match

# ---------------------
# Utility Functions
# ---------------------

#' Create Python Version
#'
#' This function creates a named list representing a Python version string from its components.
#'
#' @param version, subversion, patchlevel, releaseCandidate Version components.
#' @return A list representing the Python version.
createPythonVersion <- function(major = "", minor = "", patch = "", releaseType = "", releaseVersion = "") {
  # Store the components in a named list
  return(list(
    major = as.integer(major),
    minor = as.integer(minor),
    patch = as.integer(patch),
    releaseType = as.character(releaseType),
    releaseVersion = as.integer(releaseVersion)
  ))
}

#' Print Python version string
#'
#' This function creates a string representation of a Python version.
#'
#' @param pythonVerion A named list representing the Python version.
#' @return A string representation of the Python version.
printPythonVersion <- function(pythonVerion) {
  return(paste0(
    ifelse(is.na(pythonVerion$major), "", as.character(pythonVerion$major)),
    ifelse(is.na(pythonVerion$minor), "", paste0(".", as.character(pythonVerion$minor))),
    ifelse(is.na(pythonVerion$patch), "", paste0(".", as.character(pythonVerion$patch))),
    ifelse(is.na(pythonVerion$releaseType), "", pythonVerion$releaseType),
    ifelse(is.na(pythonVerion$releaseVersion), "", pythonVerion$releaseVersion)
  ))
}

#' Extract Python Version
#'
#' This function extracts a named list representing Python version from a string by matching a regular expression.
#'
#' @param versionString A Python version string like "3.10.0a0"
#' @return A named list representing the Python version
extractPythonVersion <- function(versionString) {
  # Check PIP 440 and implementation for an even more extensive version regex. This represents a resonable subset
  # of what to expect in the wild (https://www.python.org/dev/peps/pep-0440/#version-scheme), but might need to be
  # extended for specific use cases such as post-releases or local versions.
  versionRegex <- regex("
    v?                    # Leading v
    (?<major>[0-9]+)\\.?  # Major version
    (?<minor>[0-9]+)?\\.? # Minor version
    (?<patch>[0-9]+)?     # Patch version
    [-_\\.]?              # Possible separator
    (?<rtype>alpha|a|beta|b|preview|pre|c|rc)? # Release type
    [-_\\.]?             # Possible separator
    (?<rnum>[0-9]+)?     # Release number
    ", comments = TRUE)
  # str_match a matrix with first column containing the entire match and then all individual group patterns with
  # columns named after the group names
  matches <- str_match(versionString, versionRegex)
  return(createPythonVersion(
    major = matches[, "major"],
    minor = matches[, "minor"],
    patch = matches[, "patch"],
    releaseType = matches[, "rtype"],
    releaseVersion = matches[, "rnum"]
  ))
}

#' Compare Python Versions
#'
#' This function compares two Python versions
#'
#' @param operator Comparison operator. One of '==', '!=', '>', '>=', '<' or '<='
#' @param first First Python version (represented as named list)
#' @param second Second Python version (represented as named list) to compare against
#' @param strict Strict comparison of version components (e.g. 3.10 != 3.10.0)
#' @return TRUE operator is satisfied, FALSE otherwise
comparePythonVersions <- function(operator, first, second, strict = TRUE) {
  # Compare individual components of the version strings in decreasing order of importance
  for (component in c("major", "minor", "patch", "releaseVersion")) {
    # If strict comparison is not required and the component is NA in either version, skip the comparison
    if (!strict && (is.na(first[[component]]) || is.na(second[[component]]))) next
    # Choosing -1 for NA means missing version components are considered less than 0.
    # Hence, a version like 3.10 (= 3.10.NA) would be considered less than 3.10.0.
    v1 <- ifelse(is.na(first[[component]]), -1, first[[component]])
    v2 <- ifelse(is.na(second[[component]]), -1, second[[component]])
    # Since we're comparing in decreasing order of importance, we can continue if components are equal ..
    if (v1 == v2) next
    # .. or immediately return the result of the comparison if they are not equal
    return(switch(operator,
      ">=" = v1 >= v2,
      "==" = v1 == v2,
      "<=" = v1 <= v2,
      "!=" = v1 != v2,
      ">" = v1 > v2,
      "<" = v1 < v2,
      stop("Invalid operator '", operator, "'. Must be either '==', '!=', '>', '>=', '<' or '<='.")
    ))
  }
  # If all components are equal or NA (in non-strict mode), return the result of the equality comparison
  return(switch(operator,
    ">=" = TRUE,
    "==" = TRUE,
    "<=" = TRUE,
    FALSE
  ))
}

#' Create a named list representation of a Python dependency
#'
#' This function creates a named list representing a dependency on a particular Python package
#'
#' @param name Name of the dependency
#' @param operator Comparison operator. One of '==', '!=', '>', '>=', '<' or '<='
#' @param version Named list representation of the Python version of the dependency
#' @param build Build version of the dependency
#' @param repo Repository URL of the dependency
createPythonDependency <- function(name = "", operator = "", version = createPythonVersion(), build = "", repo = "") {
  return(list(
    name = name,
    operator = operator,
    version = version,
    build = build,
    repo = repo
  ))
}

#' Extract Python dependency from dependency string
#'
#' This function extracts the package name, relationship operator and version from a typical Python dependency string
#' (e.g. "numpy==1.26.4") and returns a named list representing the dependency. Dependencies on specific repositories
#' are also supported (e.g. "climate-assessment @ <URL to git repo>")
#'
#' @param dependency Dependency string such as "numpy<=2.0"
#' @param style Style of the dependency string. Either "pip" or "conda"
#' @return A named list representation of the Pzthon package name and version
extractPythonDependency <- function(depString, style = "pip") {
  if (grepl(" @ ", depString)) {
    if (style == "conda") {
      warning("Invalid dependency string: Conda dependencies cannot contain repository URLs")
    }
    # Example: "climate-assessment @ <URL to git repo> -> Split at "@", first part is dependency name,
    # second part is repo URL
    pattern <- "(.*)( @ )(.*)"
    splitDepString <- strcapture(pattern, depString, proto = list(name = "", operator = "", repo = ""))
    splitRepoString <- strsplit(splitDepString$repo, "@")[[1]]
    return(createPythonDependency(
      splitDepString[1],
      " @ ",
      createPythonVersion(),
      build = splitRepoString[2],
      repo = splitRepoString[1]
    ))
  } else if (style == "conda") {
    # Example: "pip=24.0=pyhd8ed1ab_0" -> Split at "=", first part is dependency name, second part is version,
    # third part is build
    splitDepString <- strsplit(depString, "=")[[1]]
    extractPythonVersion(splitDepString[2])
    return(createPythonDependency(
      splitDepString[1],
      "==",
      extractPythonVersion(splitDepString[2]),
      build = splitDepString[3],
      repo = ""
    ))
  } else if (style == "pip") {
    # Example: "climate_assessment==0.1.4a0" -> Split at "==", first part is dependency name, second part is version
    pattern <- "(.*)(==|>=|<=|>|<|!=)(.*)"
    splitDepString <- strcapture(pattern, depString, proto = list(name = "", operator = "", version = ""))
    return(createPythonDependency(
      splitDepString$name,
      splitDepString$operator,
      extractPythonVersion(splitDepString$version),
      build = "",
      repo = ""
    ))
  } else {
    stop("Invalid argument: 'style' should be either 'pip' or 'conda'")
  }
}

# ---------------------
# Main Functions
# ---------------------

#' Check Python Dependencies and Optionally Their Versions
#'
#' Checks if the required Python dependencies can actually be imported in the Python environment provided. Relies on reticulate::import. Optionally check if versions are met.
#'
#' @param dependencies Vector of dependency strings.
#' @param action Action to take if a dependency is missing. Either "stop", "warn", "note", or "pass".
#' @param checkVersion Logical indicating whether to check for matching versions.
#' @return TRUE if all dependencies are installed, FALSE otherwise.
#' @example
#' deps <- c("climate_assessment==0.1.4a0", "numpy<2.0")
#' checkPythonDeps(deps, action="stop", checkVersion = TRUE, verbose = TRUE)
checkPythonDeps <- function(dependencies, action = "stop", checkVersion = FALSE, verbose = FALSE) {
  stopifnot(action %in% c("stop", "warn", "note", "pass"))
  # Keep track of missing dependencies
  missingDependencies <- c()
  for (dependencyString in dependencies) {
    dependency <- extractPythonDependency(dependencyString)
    tryCatch(
      {
        pythonModule <- import(dependency$name)
        if (checkVersion) {
          installedVersion <- extractPythonVersion(pythonModule$`__version__`)
          correctVersion <- comparePythonVersions(dependency$operator, installedVersion, dependency$version)
          if (!correctVersion) {
            missingDependencies <- c(
              missingDependencies,
              paste0(dependencyString, " (found version: ", printPythonVersion(installedVersion), ")")
            )
          }
        }
      },
      error = function(e) {
        missingDependencies <<- c(missingDependencies, dependencyString)
      }
    )
  }
  # Error handling when dependencies are missing
  if (length(missingDependencies) > 0 && action == "stop") {
    stop("Python dependencies not satisfied: ", paste(missingDependencies, collapse = ", "))
  } else if (length(missingDependencies) > 0 && action == "warn") {
    warning("Python dependencies not satisfied: ", paste(missingDependencies, collapse = ", "))
    return(invisible(FALSE))
  } else if (length(missingDependencies) > 0 && action == "note") {
    message("Python dependencies not satisfied: ", paste(missingDependencies, collapse = ", "))
    return(invisible(FALSE))
  } else {
    return(invisible(TRUE))
  }
}

#' Check Python Dependencies and Versions
#'
#' Checks if the required Python dependencies are installed and if version requirements are met.
#'
#' @param requiredPackages Vector of required packages with optional versions.
#' @param installedPackages Vector of installed packages with versions.
#' @param checkVersion Logical indicating whether to check for matching versions.
#' @return Vector of missing packages.
checkInstalledPackages <- function(requiredPackages, installedPackages, checkVersion = FALSE) {
  # Extract package names and versions
  requiredInfos <- purrr::map(requiredPackages, extractPythonDependency)
  requiredNames <- purrr::map_chr(requiredInfos, "name")
  requiredVersions <- purrr::map_chr(requiredInfos, "version")

  installedInfos <- purrr::map(installedPackages, extractPythonDependency)
  installedNames <- purrr::map_chr(installedInfos, "name")
  installedVersions <- purrr::map_chr(installedInfos, "version")

  # Check if packages are installed and versions match
  if (checkVersion) {
    missingPackages <- requiredPackages[!(
      requiredNames %in% installedNames & purrr::map2_lgl(requiredVersions, installedVersions, comparePythonVersions) == 0)]
  } else {
    missingPackages <- requiredPackages[!(requiredNames %in% installedNames)]
  }

  return(missingPackages)
}